<!DOCTYPE html>
<html>

<head>
  <title>Early 20th Century Women Scientists in Tokyo</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9/dist/leaflet.css">
  <!-- fonts -->
  <!-- link to Montserrat font -->
  <link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
  <!-- link to Orpheus Pro Bold font -->
  <link href="https://db.onlinewebfonts.com/c/81651a191b7129993b0871c834a19600?family=OrpheusPro-Bold" rel="stylesheet">
  <!-- link to Poppins font -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300&display=swap" rel="stylesheet">
  <!-- for the collapsible sidebar -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" />
  <link rel="stylesheet" href="src/leaflet-sidebar.css" />

  <style>
    body {
      margin: 0;
      padding: 0;
      background: rgba(55, 25, 10, 1);
    }

    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 100%;
      background: rgba(55, 25, 10, 1);
    }

    /* Prevent the rotation control background from changing colors on click */
    .leaflet-control-rotate a,
    .leaflet-control-rotate a:active,
    .leaflet-control-rotate a:focus {
      background-color: rgba(254, 246, 217, 1) !important;
    }

    /* Give it a slightly darker background on hover */
    .leaflet-control-rotate a:hover {
      background-color: rgb(239, 232, 205) !important;
      /* Change cursor to grabbing */
      cursor: grabbing !important;
    }

    /* Change cursor to grabbing on hover */
    .leaflet-control-rotate-arrow:hover {
      cursor: grabbing !important;
    }

    /* Change cursor to grabbing (closed hand) on click */
    .leaflet-control-rotate-arrow:active {
      cursor: grabbing !important;
    }

    /* Style the zoom control background */
    .leaflet-control-zoom a,
    .leaflet-control-zoom a:active,
    .leaflet-control-zoom a:focus {
      background-color: rgba(254, 246, 217, 1) !important;
    }

    /* Style the zoom control background on hover */
    .leaflet-control-zoom a:hover {
      background-color: rgb(239, 232, 205) !important;
      /* Change cursor to pointer */
      cursor: pointer !important;
    }

    h1 {
      color: white;
      font-size: 16px;
      display: inline-block;
      margin-top: 0.5em;
      margin-bottom: 0.0em;
      margin-left: 0.8em;
      margin-right: 0;
      font-weight: normal;
      font-family: "Montserrat";
    }

    h2 {
      font-size: 12px;
      color: white;
      display: inline-block;
      margin-top: 0.25em;
      margin-bottom: 0.0em;
      margin-left: 1.0em;
      margin-right: 0;
      font-weight: normal;
      font-family: "Montserrat";
    }

    h4 {
      font-size: 16px;
      margin: 4px;
    }

    h5 {
      font-size: 13px;
      margin: 4px;
    }

    /* Custom style for the popup content */
    .leaflet-popup-content {
        background-color: rgba(254, 246, 217, 1);
    }

    /* Custom style for the popup tip (triangle) */
    .leaflet-popup-tip {
        background-color: rgba(254, 246, 217, 1);
    }

    /* Adjust padding and border for the popup content wrapper */
    .leaflet-popup-content-wrapper {
      background-color: rgba(254, 246, 217, 1);
    }

    .custom-tooltip {
        /* Set the maximum width */
        max-width: 300px;
    }

    /* Style the tooltip content */
    .custom-tooltip h4 {
        font-weight: normal;
        font-family: "OrpheusPro-Bold";
        font-size: 12px;
        margin: 0;
    }

    .custom-tooltip h5 {
        font-weight: normal;
        font-family: "Montserrat";
        font-size: 11px;
        margin: 0;
    }

    /* Style the chapter content */
    h6 {
      font-weight: normal;
      font-family: "OrpheusPro-Bold";
      font-size: 15px;
      margin: 0;
    }

    h7 {
      font-weight: normal;
      font-family: "Poppins", sans-serif;
      font-size: 12px;
      margin: 0;
    }

    /* Legend styles */
    .legend,
    .caseLegend {
      padding: 6px 8px;
      font-size: 1em;
      background: rgba(75, 75, 75, 0.8);
      color: whitesmoke;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
      border-radius: 5px;
      width: 180px;
    }

    .overlay-item {
      position: relative;
      background-color: white;
      width: 12px;
      height: 12px;
      margin-right: 5px;
      display: inline-block;
    }

    .overlay-item-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: inline-block;
    }

    /* collapsible div css */
    .header {
      display: flex;
      align-items: center;
    }

    #collapseButton {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 1rem;
      color: #333;
      margin-right: 10px;
      /* Add some spacing between the button and the h2 element */
    }

    #collapseButton .icon {
      margin-right: 5px;
    }

    /* lockup styles */
    .sidebar-pane {
      display: flex;
      align-items: center;
    }

    .svg-container {
      display: flex;
      /* Arrange logos horizontally */
      max-height: 120px;
      width: 100%;
      overflow: hidden;
    }

    .svg-item {
      flex: 0 0 auto;
      /* Prevent logos from growing or shrinking */
      margin-right: -150px;
      /* Adjust the margin to control the spacing between logos */
      margin-left: -160px;
      margin-bottom: -35px;
    }

    /* For maintaining aspect ratio, set either width or height to "auto" */
    .svg-item img {
      width: 400px;
      /* Set the desired width for the SVG logo */
      height: auto;
      /* Set height to "auto" for maintaining aspect ratio */
    }

    /* custom sidebar css */
    /* sidebar header */
    .sidebar-header {
      width: 100%;
      font-family: "OrpheusPro-Bold";
    }

    /* sidebar icon */
    i {
      color: rgb(0, 0, 0);
    }

    /* sidebar about heading */
    .about {
      color: rgb(0, 0, 0);
      font-family: "OrpheusPro-Bold";
      font-size: 16px;
      margin-bottom: 0px;
      margin-top: 0px;
      margin-left: 0px;
    }

    /* selection heading */
    .choose {
      color: rgb(0, 0, 0);
      font-family: "OrpheusPro-Bold";
      font-size: 16px;
      margin-bottom: 0px;
      margin-top: 0px;
      margin-left: 0px;
    }

    /* map info */
    .details {
      font-family: 'Poppins', sans-serif;
      font-size: 13px;
      font-weight: normal;
      margin-bottom: 0px;
      margin-top: 0px;
    }

    .instructions {
      font-family: 'Poppins', sans-serif;
      font-size: 12px;
      font-weight: normal;
      margin-bottom: 0px;
      margin-top: 0px;
    }

    .introbreak {
      display: block;
      margin-bottom: 1em;
    }
  </style>
</head>

<body>

  <div id="sidebar" class="sidebar collapsed">
    <div class="sidebar-tabs">
      <ul role="tablist">
        <li><a href="#home" role="tab"><i class="fa fa-bars"></i></a></li>
      </ul>
    </div>
    <div class="sidebar-content">
      <div class="sidebar-pane" id="home">
        <h1 class="sidebar-header">Women Scientists in Pre-War Tokyo<span class="sidebar-close"><i
              class="fa fa-caret-left"></i></span></h1><br>
        <br>
        <div class="header">
          <button id="collapseButton"><span class="icon"><i class="fas fa-chevron-up"></i></span></button>
          <h2 class="about">About This Project</h2>
        </div>
        <div id="collapsibleContent">
          </b><br>
          <h3 class="details">The dominant narrative of modern Japan's scientific journey has centered on the contributions of male scientists and male-only academic institutions. This project is an attempt to undo the erasure of women scientists and affirm their contributions to science in early twentieth-century Japan. Although the government was not active in promoting womenâ€™s higher education and training women scientists, ambitious women and their supporters created spaces where women could engage in scientific inquiry. By mapping these sites and naming the women scientists associated with them, this project demonstrates that women were part of the development of modern science in Japan.</h3>
          <p style="padding-bottom:0px"></p>
        </div>
        <div id="radio-select">
          <p>
          <h2 class="choose">Choose from the following options.</h2>
          </p>
          <input type="radio" id="option-one" name="select" value="option-one" checked>
          <label for="option-one">Academic Institutions</label><br>

          <input type="radio" id="option-two" name="select" value="option-two">
          <label for="option-two">Scientists</label><br>
        </div>
        <div id="dropdown-instructions">
          <p>
          <h2 class="choose">Select your topic of interest.</h2>
          </p>
        </div>
        <form id="map_parameters" name="map_parameters" action="#" accept-charset="utf-8" class="inlineForm"><select
            id="chapter-select" class="div-toggle" data-target=".my-info-1"></select></form>
        <!-- Add a button to trigger the handleZoomOutClick() function -->
        <div id="search-instructions">
          <p>
          <!--<h2 class="choose">Click the search button or zoom back to Tokyo.</h2>-->
          <h2 class="choose">Or zoom back to the complete map.</h2>
          </p>
        </div>
        <!-- Wrap the buttons in a container div to control their layout -->
        <div class="button-container">
          <!--<button onclick="handleButtonClick()">Search</button>-->
          <button onclick="handleZoomOutClick()">Zoom Out</button>
        </div>
        <span class='introbreak'></span>
        <div id="sidebar-info" class="my-info-1">
          <div id="content-info" class="contentinfo hide"></div>
        </div>
      </div>
    </div>
  </div>

  <div id="map"></div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9/dist/leaflet-src.js"></script>
  <!-- jQuery -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"
    integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <!-- Leaflet-Rotate -->
  <script src="src/leaflet-rotate-src.js"></script>
  <!-- sidebar -->
  <script src="src/svg-icon.js"></script>
  <script src="src/leaflet-sidebar.js"></script>

  <script>

    const historic = L.tileLayer('./tokyo-map-tiles/{z}/{x}/{y}.png', {
      tms: 1,
      minZoom: 10,
      maxZoom: 16,
    });

    const map = L.map('map', {
      //center: [35.651815, 139.753943],
      center: [35.6470073, 139.7524151],
      zoom: 13,
      layers: [historic],
      // worldCopyJump: true,
      // preferCanvas: false,
      rotate: true,
      rotateControl: {
        closeOnZeroBearing: false,
        // position: 'bottomleft',
      },
      bearing: 79,
      // attributionControl: false,
      // zoomControl: false,
      // compassBearing: true,
      // trackContainerMutation: false,
      // shiftKeyRotate: false,
      // touchGestures: true,
      touchRotate: true,
      // touchZoom: true
    });

    // move the zoom control to the top right corner
    map.zoomControl.setPosition('topright');

    // move the rotate control to the top right corner
    map.rotateControl.setPosition('topright');

    // add a sidebar to the map
    const sidebar = L.control.sidebar("sidebar").addTo(map);
    sidebar.open("home");

    // code to collapse about content
    const collapseButton = document.getElementById('collapseButton');
    const collapsibleContent = document.getElementById('collapsibleContent');

    collapseButton.addEventListener('click', function () {
      if (collapsibleContent.style.display === 'none') {
        collapsibleContent.style.display = 'block';
        collapseButton.innerHTML = '<span class="icon"><i class="fas fa-chevron-up"></i></span>';
      } else {
        collapsibleContent.style.display = 'none';
        collapseButton.innerHTML = '<span class="icon"><i class="fas fa-chevron-down"></i></span>';
      }
    });

    // Define the map bounds
    //const mapBounds = [[35.59883, 139.68365],[35.76010, 139.83842]];

    // Define the handleButtonClick() function
    function handleButtonClick() { };

    // Define the handleZoomOutClick() function
    function handleZoomOutClick() {
      // set the map center
      //map.setView([35.651815, 139.753943], 13);
      map.setView([35.6470073, 139.7524151], 13);
      // set the map bearing
      map.setBearing(79);
    };

    // define an empty array to hold the sidebar selected content
    const chapterContent = [];
    // define an empty array to hold all institution names
    const institutionList = [];
    // define an empty array to hold all scientist names
    const scientistList = [];
    // define sidebar info
    const info = document.getElementById("content-info");

    let universities; // Declare universities outside of the $.when().done() block
    let biographies; // Declare biographies outside of the $.when().done() block
    // Declare a layer group to hold markers
    let markers = L.layerGroup();

    // use jquery to load GeoJSON data
    $.when(
      $.getJSON('json/tokyo-institutions.geojson'),
      $.getJSON('json/biographies.geojson')
    ).done(function (inst, bios) {

      // create a layer for the universities
      universities = L.geoJson(inst, {
        // style the layer
        style: function (feature) {
          return {
            color: '#0072CE',
            weight: 1,
            opacity: 1,
            fillColor: '#0072CE',
            fillOpacity: 0.45,
          };
        },
        // add a popup to the layer
        onEachFeature: function (feature, layer) {

          // define the properties
          let props = feature.properties;
          // define the contemporary name
          let contName = props.Cont_Name;
          // define the historical name
          let histName = props.Hist_Name;
          // leave uniName as an undefined variable
          let uniName;
          // if the contemporary name is different from the historical name
          if (contName !== histName) {
            // define the uniName variable as a concatenation of the contemporary name and the historical name
            uniName = contName + '<br><i>' + histName + '</i>';
          } else {
            // define the uniName variable as the contemporary name
            uniName = contName;
          };

          layer.bindPopup('<h4>' + uniName + '</h4><hr><h5>' + feature.properties.Description + '</h5>', {
            sticky: true,
            direction: 'top',
            opacity: 0.9,
            className: 'custom-tooltip',
          });
          // on hover, highlight the feature and open the popup
          layer.on({
            mouseover: function (e) {
              this.openPopup();
              this.setStyle({
                color: 'gold',
                weight: 2,
                opacity: 1,
                fillColor: 'gold',
                fillOpacity: 0.75,
              });
            },
            mouseout: function (e) {
              //this.closePopup();
              this.setStyle({
                color: '#0072CE',
                weight: 1,
                opacity: 1,
                fillColor: '#0072CE',
                fillOpacity: 0.45,
              });
            },
          });
        },
      });

      // Create a marker layer for the bios
      biographies = L.geoJson(bios, {
        // assign markers to each point
        pointToLayer: function (feature, latlng) {
          return L.marker(latlng, {
            icon: L.icon({
              iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
              shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
              iconSize: [25, 41],
              iconAnchor: [12, 41],
              popupAnchor: [1, -34],
              shadowSize: [41, 41]
            })
          });
        },
        onEachFeature: function(feature, layer) {

          // define the properties
          let props = feature.properties;
          // define the contemporary name
          let contName = props.Cont_Name;
          // define the historical name
          let histName = props.Hist_Name;
          // leave uniName as an undefined variable
          let uniName;
          // if the contemporary name is different from the historical name
          if (contName !== histName) {
            // define the uniName variable as a concatenation of the contemporary name and the historical name
            uniName = contName + '<br><i>' + histName + '</i>';
          } else {
            // define the uniName variable as the contemporary name
            uniName = contName;
          }; 

          layer.bindPopup('<h4>' + feature.properties.Name + '<br>' + uniName + '</h4><hr><h5>' + feature.properties.Bio + '</h5>', {
            sticky: true,
            direction: 'top',
            opacity: 0.9,
            className: 'custom-tooltip'
          });
          // on mouseover
          layer.on('mouseover', function (e) {
            // open the popup
            this.openPopup();
            // highlight the feature
            this.setIcon(L.icon({
              iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-gold.png',
              shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
              iconSize: [25, 41],
              iconAnchor: [12, 41],
              popupAnchor: [1, -34],
              shadowSize: [41, 41]
            }));
          });
          // on mouseout
          layer.on('mouseout', function (e) {
            // reset the icon
            this.setIcon(L.icon({
              iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
              shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
              iconSize: [25, 41],
              iconAnchor: [12, 41],
              popupAnchor: [1, -34],
              shadowSize: [41, 41]
            }));
          });
        }
      });

      // If the option-one radio button is selected, add the universities layer to the map
      if (getSelectedRadioValue() == "option-one") {
        // remove the bios layer from the map
        map.removeLayer(biographies);
        // remove the markers layer group from the map
        map.removeLayer(markers);
        // clear the dropdown
        document.getElementById('chapter-select').innerHTML = '';
        // clear the institutionList array
        institutionList.length = 0;
        // clear the scientistList array
        scientistList.length = 0;
        // add the universities layer to the map
        universities.addTo(map);
        // iterate through the universities layer
        universities.eachLayer(function (layer) {
          // add the institution name to the institutionList array
          institutionList.push(layer.feature.properties.Cont_Name);
          // sort the institutionList array alphabetically
          institutionList.sort();
          // define the chapter-select dropdown content using each institution name from the institutionList array
          let eachInstitution = institutionList.filter((v, i, a) => a.indexOf(v) === i);
          let tmpHTML = '<select class="custom-select"><option value="0">Select a University</option>';
          for (let i = 0; i < eachInstitution.length; i++) {
            tmpHTML += '<option value="' + eachInstitution[i] + '">' + eachInstitution[i] + '</option>';
          }
          tmpHTML += '</select>';
          document.getElementById('chapter-select').innerHTML = tmpHTML;
        });
      } // Otherwise, remove the universities layer from the map
      else {
        // remove the universities layer from the map
        map.removeLayer(universities);
        // remove the markers layer group from the map
        map.removeLayer(markers);
        // clear the dropdown
        document.getElementById('chapter-select').innerHTML = '';
        // clear the institutionList array
        institutionList.length = 0;
        // clear the scientistList array
        scientistList.length = 0;        
        // add the bios layer to the map
        biographies.addTo(map);
        // iterate through the bios layer
        biographies.eachLayer(function (layer) {
          // add the scientist name to the scientistList array
          scientistList.push(layer.feature.properties.Name);
          // sort the scientistList array alphabetically
          scientistList.sort();
          // define the chapter-select dropdown content using each scientist name from the scientistList array
          let eachScientist = scientistList.filter((v, i, a) => a.indexOf(v) === i);
          let tmpHTML = '<select class="custom-select"><option value="0">Select a Scientist</option>';
          for (let i = 0; i < eachScientist.length; i++) {
            tmpHTML += '<option value="' + eachScientist[i] + '">' + eachScientist[i] + '</option>';
          }
          tmpHTML += '</select>';
          document.getElementById('chapter-select').innerHTML = tmpHTML;
        });
      };

      // On radio button change...
      $('input[type=radio][name=select]').change(function () {
        // clear the chapterContent array
        chapterContent.length = 0;
        info.innerHTML = chapterContent.join('');
        // If the option-one radio button is selected, add the universities layer to the map
        if (document.getElementById('option-one').checked) {
          // remove the bios layer from the map
          map.removeLayer(biographies);
          // remove the markers layer group from the map
          map.removeLayer(markers);
          // clear the dropdown
          document.getElementById('chapter-select').innerHTML = '';
          // clear the institutionList array
          institutionList.length = 0;
          // clear the scientistList array
          scientistList.length = 0;
          // add the universities layer to the map
          universities.addTo(map);
          // iterate through the universities layer
          universities.eachLayer(function (layer) {
            // add the institution name to the institutionList array
            institutionList.push(layer.feature.properties.Cont_Name);
            // sort the institutionList array alphabetically
            institutionList.sort();
            // define the chapter-select dropdown content using each institution name from the institutionList array
            let eachInstitution = institutionList.filter((v, i, a) => a.indexOf(v) === i);
            let tmpHTML = '<select class="custom-select"><option value="0">Select a University</option>';
            for (let i = 0; i < eachInstitution.length; i++) {
              tmpHTML += '<option value="' + eachInstitution[i] + '">' + eachInstitution[i] + '</option>';
            }
            tmpHTML += '</select>';
            document.getElementById('chapter-select').innerHTML = tmpHTML;
          });
        } // Otherwise, remove the universities layer from the map
        else {
          // remove the universities layer from the map
          map.removeLayer(universities);
          // remove the markers layer group from the map
          map.removeLayer(markers);
          // clear the dropdown
          document.getElementById('chapter-select').innerHTML = '';
          // clear the institutionList array
          institutionList.length = 0;
          // clear the scientistList array
          scientistList.length = 0;
          // add the bios layer to the map
          biographies.addTo(map);
          // iterate through the bios layer
          biographies.eachLayer(function (layer) {
            // add the scientist name to the scientistList array
            scientistList.push(layer.feature.properties.Name);
            // sort the scientistList array alphabetically
            scientistList.sort();
            // define the chapter-select dropdown content using each scientist name from the scientistList array
            let eachScientist = scientistList.filter((v, i, a) => a.indexOf(v) === i);
            let tmpHTML = '<select class="custom-select"><option value="0">Select a Scientist</option>';
            for (let i = 0; i < eachScientist.length; i++) {
              tmpHTML += '<option value="' + eachScientist[i] + '">' + eachScientist[i] + '</option>';
            }
            tmpHTML += '</select>';
            document.getElementById('chapter-select').innerHTML = tmpHTML;
          });
        };
      });

      // On dropdown change...
      $('#chapter-select').change(function () {
        handleButtonClick();
      });
        
    });

    // Function to get the selected radio value
    function getSelectedRadioValue() {
      const radioButtons = document.getElementsByName('select');
      let selectedRadioValue = null;
      radioButtons.forEach(radio => {
        if (radio.checked) {
          selectedRadioValue = radio.value;
        }
      });
      return selectedRadioValue;
    };

    // Function to get the selected value from the dropdown
    function getSelectedDropdownValue() {
      const dropdown = document.getElementById('chapter-select');
      const selectedDropdownValue = dropdown.value;
      return selectedDropdownValue;
    };

    // Function to get both the radio selection and the dropdown selection
    function getSelections() {
        const radioSelection = getSelectedRadioValue();
        const dropdownSelection = getSelectedDropdownValue();
        // You can use the values here, or return them as an object or an array
        // For this example, I will return an object
        return {
            radio: radioSelection,
            dropdown: dropdownSelection
        };
    };
    
    // Define the handleButtonClick() function
    function handleButtonClick() {
      
      // clear the chapterContent array
      chapterContent.length = 0;
      info.innerHTML = chapterContent.join('');

      // Get the selections
      const selections = getSelections();
      const radioSelection = selections.radio;
      const dropdownSelection = selections.dropdown;   

      // If the radio selection is "option-one"
      if (radioSelection == "option-one") {
        // iterate through the universities layer
        universities.eachLayer(function (layer) {
          // if the dropdown selection matches the institution name
          if (dropdownSelection == layer.feature.properties.Cont_Name) {
            // Get the bounds of the polygon
            let bounds = layer.getBounds();
            // Define the sidebar width in pixels
            let sidebarWidth = document.getElementById('sidebar').offsetWidth;
            // Define the sidebar width as longitudinal decimal degrees at a zoom level of 16
            let sidebarWidthDegrees = sidebarWidth / 2.06 ** 16;
            // Convert bearing of 79 to radians
            let bearingRadians = (79 * Math.PI) / 180;
            // Calculate the offset in longitude and latitude directions
            let offsetLng = Math.cos(bearingRadians) * sidebarWidthDegrees;
            let offsetLat = Math.sin(bearingRadians) * sidebarWidthDegrees;
            // Define new bounds with the offsets
            let neLat = bounds._northEast.lat - offsetLat;
            let neLng = bounds._northEast.lng - offsetLng;
            let swLat = bounds._southWest.lat - offsetLat;
            let swLng = bounds._southWest.lng - offsetLng;
            // Use these bounds to fit the map
            map.fitBounds([[neLat, neLng], [swLat, swLng]]);         
            // Set the map bearing to 79
            map.setBearing(79);
            // open the popup
            layer.openPopup();

            // define the properties
            let props = layer.feature.properties;
            // define the contemporary name
            let contName = props.Cont_Name;
            // define the historical name
            let histName = props.Hist_Name;
            // leave uniName as an undefined variable
            let uniName;
            // if the contemporary name is different from the historical name
            if (contName !== histName) {
              // define the uniName variable as a concatenation of the contemporary name and the historical name
              uniName = contName + '<br><i>' + histName + '</i>';
            } else {
              // define the uniName variable as the contemporary name
              uniName = contName;
            };             

            // Build out the chapterContent array
            chapterContent.push('<h6>' + uniName + '</h6><hr><h7>' + layer.feature.properties.Description + '<br><br><b>Scientists:</b><br>' + layer.feature.properties.Scientists + '</h7>');
            // Join the chapterContent array, and set it as the innerHTML of the info div
            info.innerHTML = chapterContent;
          }
        });
      } else {
        // remove the biographies layer from the map
        map.removeLayer(biographies);
        // clear the markers layer group
        markers.clearLayers();
        // iterate through the bios layer
        biographies.eachLayer(function (layer) {
          // if the dropdown selection matches the scientist name
          if (dropdownSelection == layer.feature.properties.Name) {

            // push the layer to the markers layer group
            markers.addLayer(layer);

            // add the markers layer group to the map
            map.addLayer(markers);

            // Build out the chapterContent array
            let content = '<h6>' + layer.feature.properties.Name + '<br>';

            // Collect unique Cont_Names for the selected Name
            let contNames = [];

            biographies.eachLayer(function (subLayer) {
              
              // define the properties
              let props = subLayer.feature.properties;
              // define the contemporary name
              let contName = props.Cont_Name;
              // define the historical name
              let histName = props.Hist_Name;
              // leave uniName as an undefined variable
              let uniName;
              // if the contemporary name is different from the historical name
              if (contName !== histName) {
                // define the uniName variable as a concatenation of the contemporary name and the historical name
                uniName = contName + ' (' + histName + ')';
              } else {
                // define the uniName variable as the contemporary name
                uniName = contName;
              };  

              if (layer.feature.properties.Name === subLayer.feature.properties.Name) {
                // push the Cont_Name to the contNames array
                contNames.push(uniName);
              }
            });
            
            // Add each unique Cont_Name under Name
            content += contNames.join('<br>') + '</h6><hr>';
            
            // Add Bio (assuming it's the same for all Cont_Names under the same Name)
            content += '<h7>' + layer.feature.properties.Bio + '</h7>';

            // Set the innerHTML of the info div
            info.innerHTML = content;

            // Check if there are markers in the markers layer group
            if (markers.getLayers().length > 0) {
              
              // Initialize an empty LatLngBounds object
              let bounds = L.latLngBounds();

              // Iterate through each marker in the layer group
              markers.eachLayer(function (marker) {
                bounds.extend(marker.getLatLng());
              });

              // Fly the map to the bounds of the markers layer group
              map.flyToBounds(bounds, { duration: 0.485 });

            }

          }
        });

        // Set a 500 timeout
        setTimeout(function () {
              // Define the sidebar width in pixels
              let sidebarWidth = document.getElementById('sidebar').offsetWidth;
    
              // Define the sidebar width as longitudinal decimal degrees at the current zoom level
              let sidebarWidthDegrees = sidebarWidth / 2.06 ** map.getZoom();              

              // Get the center of the map
              let center = map.getCenter();

              // Get the bearing of the map
              let bearing = map.getBearing();

              // Convert bearing to radians
              let bearingRadians = (bearing * Math.PI) / 180;

              // Calculate the offset in longitude and latitude directions
              let offsetLng = Math.cos(bearingRadians) * sidebarWidthDegrees;
              let offsetLat = Math.sin(bearingRadians) * sidebarWidthDegrees;

              // Calculate the new map center
              let newMapCenter = L.latLng(
                center.lat - offsetLat,
                center.lng - offsetLng
              );

              // Pan to the new map center
              map.panTo(newMapCenter);
        }, 500);

      }
    }; 
    



    /* Some code that centers the map on a marker when the sidebar is open    
        // Wait until the sidebar is fully opened (animation is finished)
        sidebar.on('opening', function (ev) {
          // After a short delay (e.g., 500 milliseconds), zoom in
          setTimeout(function() {
            
            // Define the sidebar width in pixels
            const sidebarWidth = document.getElementById('sidebar').offsetWidth;
    
            // Define the sidebar width as longitudinal decimal degrees at the current zoom level
            const sidebarWidthDegrees = sidebarWidth / 2.06 ** map.getZoom();
    
    
            // Get the map center
            const mapCenter = map.getCenter();
    
            // Get the map bearing
            const mapBearing = map.getBearing();
    
            // Convert bearing to radians
            const bearingRadians = (mapBearing * Math.PI) / 180;
    
            // Calculate the offset in longitude and latitude directions
            const offsetLng = Math.cos(bearingRadians) * sidebarWidthDegrees;
            const offsetLat = Math.sin(bearingRadians) * sidebarWidthDegrees;
    
            // Calculate the new map center
            const newMapCenter = L.latLng(
              mapCenter.lat + offsetLat,
              mapCenter.lng + offsetLng
            );
    
            // Get the marker latlng
            const markerLatLng = marker.getLatLng();
            // Get the marker lat
            const markerLat = markerLatLng.lat;
            // Get the marker lng
            const markerLng = markerLatLng.lng;
            // Adjust markerLat by subtracting offsetLat
            const newMarkerLat = markerLat - offsetLat;
            // Adjust markerLng by subtracting offsetLng
            const newMarkerLng = markerLng - offsetLng;
    
            // Set the map center with new marker latlng
            map.setView([newMarkerLat, newMarkerLng], map.getZoom());
    
          }, 500);
        });
    */


    /* Some code to shift the map to the right when the sidebar is open 
        // Write a function to get the width of the screen outside of the sidebar
        function getMapWidth() {
          const sidebarWidth = document.getElementById('sidebar').offsetWidth;
          const mapWidth = window.innerWidth - sidebarWidth;
          return mapWidth;
        };
    
        const originalMapWidth = getMapWidth();
    
        // Wait until the sidebar is fully closed (animation is finished)
        sidebar.on('closing', function (ev) {
          // After a short delay (e.g., 500 milliseconds), zoom in
          setTimeout(function() {
            // Define the percentage of the screen width that the map should occupy
            let mapWidthPercentage = getMapWidth() / originalMapWidth * 100;
            let mapLeft = 100 - mapWidthPercentage;
            // Using mapLeft, reset the map css left property
            map.getContainer().style.left = mapLeft + '%';
            map.getContainer().style.width = mapWidthPercentage + '%';
          }, 500);
        });
    
        // Wait until the sidebar is fully opened (animation is finished)
        sidebar.on('opening', function (ev) {
          // After a short delay (e.g., 500 milliseconds), zoom in
          setTimeout(function() {
            // Define the percentage of the screen width that the map should occupy
            let mapWidthPercentage = getMapWidth() / originalMapWidth * 100;
            let mapLeft = 100 - mapWidthPercentage;
            // Using mapLeft, reset the map css left property
            map.getContainer().style.left = mapLeft + '%';
            map.getContainer().style.width = mapWidthPercentage + '%';
          }, 500);
        });
    */



  </script>

</body>

</html>